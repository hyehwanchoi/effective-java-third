# 스트림에서는 부작용 없는 함수를 사용하라

* 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다.
  * 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
  * 순수 함수란 오직 입력만이 결과에 영향을 주는 함수.
* forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.

### Collector 메서드 (수집기)
* `comparing` : 키 추출 함수를 받는 비교자 생성 메서드
* `freq::get`: 입력받은 단어를 빈도표에서 찾아 그 빈도를 반환한다.
* `sorted` : `.reversed` 를 사용하여 역순으로 정렬할 수 있다.
* `toMap(keyMapper, valueMapper)` 
  * 스트림 원소를 키에 매핑하는 함수와 값에 매핑하는 함수를 인수로 받는다.
  * 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적합.
* 인수 3개를 받는 `toMap`
  * 어떤 키와 그 키에 연관된 원소들 중 하나를 골라 연관 짓는 맵을 만들 때 유용하다.
  * 마지막 값을 취하는 수집기를 만들 때도 유용하다.
* `toConcurrentMap` : 병렬 실행된 후 결과로 `ConcurrentHashmap` 인스턴스를 생성한다.
* `groupingBy`
  * 입력으로 분류함수를 받고 출력으로는 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환한다.
  * 분류 함수는 입력받은 원소가 속하는 카테고리를 반환한다.
  * `groupingBy` 가 반환하는 수집기가 리스트 외의 값을 갖는 맵을 생성하게 하려면,
    분류 함수와 함께 다운스트림 수집기도 명시해야 한다.
    * 다운스트림 수집기의 역할은 해당 카테고리의 모든 원소를 담은 스트림으로부터 값을 생성하는 일이다.
    * 다운 스트림 수집기로 `counting()` 을 사용한다면 해당 카테고리에 속하는 원소의 개수와 매핑한 맵을 얻는다.
* `groupingByConcurrent`
  * 대응하는 메서드의 동시 수행 버전으로, `ConcurrentHashMap` 인스턴스를 만들어준다.
* `partitioningBy`
  * 분류 함수 자리에 프레디키트를 받고 키가 `Boolean` 인 맵을 반화한다.
* `minBy`, `maxBy`
  * 스트림에서 값이 가장 작은 혹은 가장 큰 원소를 찾아 반환한다.
* `joining`
  * 매개변수가 없으면 원소들을 연결하는 수집기를 반환한다.
  * 인수가 하나라면 구분 문자를 매개변수로 받는다.