# 커스텀 직렬화 형태를 고려해보라

* 직렬화는 신중히 고민 후 사용해야 한다.
  * 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.
* 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
* 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다. 
* 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.
  * defaultWriteObject 메서드를 호출하면 transient 로 선언하지 않은 모든 인스턴스 필드가 직렬화된다. 따라서
    transient 로 선언해도 되는 인스턴스 필드에는 모두 transient 한정자를 붙여야 한다. 캐시된 해시 값처럼 다른 필드에는 유도되는 필드도 해당한다.
  * 기본 직렬화를 사용한다면 transient 필드들은 역직렬화될 때 기본값으로 초기화된다.
  * 기본값을 그대로 사용해서는 안 된다면 readObject 메서드에서 defaultReadObject 를 호출한 다음, 해당 필드를 원하는 값으로 복원하라.
    혹은 그 값을 처음 사용할 때 초기화하는 방법도 있다.
* 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 매커니즘을 직렬화에도 적용해야 한다.
  * 모든 메서드를 synchronized 로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면 writeObject 도 다음 코드처럼
    synchronized 로 선언해야 한다.
  * writeObject 메서드 안에서 동기화하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.
    그렇지 않으면 자원 순서 교착상태에 빠질 수 있다.
* 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID 를 명시적으로 부여하라.
  * 이렇게 하면 UID 가 일으키는 잠재적인 호환성 문제가 사라진다.
  * `private static final long serialVersionUID = <무작위로 고른 long 값>;`
* 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID 를 절대 수정하지 말자.

### 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.
1. 공개 API 가 현재의 내부 표현 방식에 영구히 묶인다.
   1. private 클래스가 공개 API 가 되어 버린다.
2. 너무 많은 공간을 차지할 수 있다.
   1. 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.
3. 시간이 많이 걸릴 수 있다.
4. 스택 오버플로를 일으킬 수 있다.

### 합리적인 직렬화 형태
* 문자열의 개수가 적고, 그 뒤로 문자열들을 나열하는 수준
