# 박싱된 기본 타입보다는 기본 타입을 사용하라.

* 참조 타입 = 박싱된 기본 타입

### 기본 타입과 박싱된 타입의 차이점
* 기본 타입은 값만 가지고 있으나 박싱된 타입은 식별성이란 속성을 갖는다.
* 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null 을 가질 수 있다.
* 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용 면에서 더 효율적이다.
####

* 박싱된 기본타입에 == 연산자를 사용하면 오류가 일어난다.
  * 식별성을 갖기 때문
* 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()` 를 사용하자.
  * 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다.
  * 그렇더라도 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다.
* 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.
* 그리고 null 참조를 언박싱하면 NullPointerException 이 발생한다.

### 박싱된 기본 타입은 언제 써야 하는가 ?
* 컬렉션의 원소, 키 값으로 쓴다.
  * 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
* 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

### 정리
* 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
* == 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullPointerException 을 던질 수 있다.
* 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용도 있을 수 있다.
  * ex) `Long sum = 0L`