# 적시에 방어적 복사본을 만들라

* 자바는 안전한 언어이다.
* 하지만 자바라도 다른 클래스로부터 침범을 다 막을 수 있는 건 아니다.
  * 그래서 방어적으로 프로그래밍을 할 필요가 있다.

## 방어적 프로그래밍 방법
### 생성자 매개변수의 방어적 복사본을 만들자
* 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.
####
    public final class Period {
      private final Date start;
      private final Date end;
  
      // 수정한 생성자 - 매개변수의 방어적 복사본을 만든다.
      public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());

        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + "가" + end + "보다 늦다.");
        }
      }
   
      public Date start() {
        return start;
      }
      public Date end() {
        return end;
      }
    }
* 멀티 스레딩 환경이라면 반드시 이렇게 작성해야 한다.
  * 유효성 검사를 수행한 후 복사본을 만드는 그 찰나에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
* 매개변수가 제 3자에 의해 확정될 수 있는 타입이라면 방어적 복사에 clone 을 사용해서는 안된다.
* getter 를 이용한 내부 공격을 가변 필드의 방어적 복사본을 만들어 방어한다.
####
    // 수정한 접근자 - 가변 필드의 방어적 복사본을 만든다.
    public Date start() {
        return new Date(start.getTime());
    }
    public Date end() {
        return new Date(end.getTime());
    }
* 일반적으로 인스턴스 복사는 생성자나 정적 팩터리를 쓰는게 좋다.

## 이 외 방어적 복사 활용 방법
### 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관하는 경우
* 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항상 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.
  * 만약 변경될 수 있는 객체라면, 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지 생각해보고 이를 확신할 수 없다면, 복사본을 만들어 저장해야 한다.

### 가변인 내부 객체가 클라이언트에 반환될 때 안심할 수 없는 경우
* 클래스가 가변이든 불변이든, 가변인 내부 객체가 클라이언트에 반환될 때 안심할 수 없는 경우라면 원본을 노출하지 말고 방어적 복사본을 반환해야 한다. 
* 길이가 1 이상인 배열은 무조건 가변이므로 내부에서 사용하는 배열을 반환할 때는 항상 방어적 복사를 수행해야 한다.

### 정리
* 되도록이면 불변 객체를 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다. 
* 방어적 복사에는 성능 저하가 따를 수밖에 없고, 또 항상 사용할 수 있는 방법도 아니다.
* 만약 복사 비용이 너무 크거나 호출자가 내부를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.