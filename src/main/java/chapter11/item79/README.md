# 과도한 동기화는 피하라

* 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.
* 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
  * 예를 들어 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
  * 교착상태에 빠지거나 데이터를 훼손할 수 있다.
* 재진입 가능 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현할 수 있도록 해주지만, 응답 불가(교착 상태)가 될 상황을 안전 실패(데이터 훼손)로 변모시킬 수도 있다.
* 동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출이라고 하는데, 열린 호출은 실패 방지 효과 외에도 동시성 효율을 크게 개선해준다.
  * 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.
  * 오래 걸리는 작업이라면 아이템 78의 지침을 어기지 않고 동기화 영역 바깥으로 옮기는 방법을 찾아보자.
* 클래스를 내부에서 동기화하기로 했다면 락 분할, 락 스트라이핑, 비차단 동시성 제어 등 다양한 기법을 동원해 동시성을 높여준다.
* 여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기화해야 한다.

### 가변 클래스 작성 시
1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.
   1. 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 선택하자.

### 정리
* 교착 상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.
* 동기화 영역 안에서의 작업은 최소한으로 줄이자.
* 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자.